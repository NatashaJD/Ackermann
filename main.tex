\documentclass[11pt, a4paper]{article}

% --- UNIVERSAL PREAMBLE BLOCK ---
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{fontspec}

\usepackage[english, bidi=basic, provide=*]{babel}

\babelprovide[import, onchar=ids fonts]{english}
\babelfont{rm}{Noto Sans}
% --- END UNIVERSAL PREAMBLE BLOCK ---

\usepackage{amsmath} % For align* environment for math steps
\usepackage{listings} % For source code listing
\usepackage{xcolor} % For colors in listings
\usepackage{hyperref} % For links (must be last package loaded)

% Define colors for code block styling
\definecolor{codegreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}

% Global Listings settings for all code blocks
\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen}\itshape,
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    showstringspaces=false,
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    frameround=tttt,
    rulesepcolor=\color{codegray}
}

% Define specific styles for the languages
\lstdefinestyle{CStyle}{
    language=C,
}
\lstdefinestyle{CppStyle}{
    language=C++,
}
\lstdefinestyle{JavaStyle}{
    language=Java,
}

\title{Analysis and Implementation of the Ackermann Function}
\author{Your Name}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Introduction}
The Ackermann function, $A(m, n)$, is a simple but extremely fast-growing function. It is defined recursively for non-negative integers $m$ and $n$ as follows:

$$
A(m, n) = \begin{cases} n+1 & \text{if } m=0 \\ A(m-1, 1) & \text{if } m>0 \text{ and } n=0 \\ A(m-1, A(m, n-1)) & \text{if } m>0 \text{ and } n>0 \end{cases}
$$

\section{Calculation of $\mathbf{A(1, 2)}$}
We will now calculate the value of $A(1, 2)$ step-by-step using the recursive definition.

\begin{align*}
A(1, 2) &= A(0, A(1, 1)) & \quad \text{(Case } m>0, n>0\text{)}\\
\intertext{First, we calculate the inner term, $A(1, 1)$:}
A(1, 1) &= A(0, A(1, 0)) & \quad \text{(Case } m>0, n>0\text{)} \\
\intertext{Next, calculate $A(1, 0)$:}
A(1, 0) &= A(0, 1) & \quad \text{(Case } m>0, n=0\text{)} \\
A(1, 0) &= 1 + 1 = 2 & \quad \text{(Case } m=0\text{)} \\
\intertext{Substitute this back into the expression for $A(1, 1)$:}
A(1, 1) &= A(0, 2) \\
A(1, 1) &= 2 + 1 = 3 & \quad \text{(Case } m=0\text{)} \\
\intertext{Finally, substitute the result for $A(1, 1)$ back into the original expression for $A(1, 2)$:}
A(1, 2) &= A(0, 3) \\
A(1, 2) &= 3 + 1 = 4 & \quad \text{(Case } m=0\text{)}
\end{align*}

Thus, the result is $\mathbf{A(1, 2) = 4}$.

\section{Source Code Implementations}
The following sections provide space to document the recursive implementation of the Ackermann function in various programming languages.

\subsection{C Implementation}
Please insert your C code below. Remember that the Ackermann function grows very quickly, and for inputs like $A(4, 1)$, a 64-bit integer will be insufficient.

\begin{lstlisting}[style=CStyle, caption={C Implementation of the Ackermann Function}, label={lst:c_code}]
// C Code goes here. Be careful of stack overflow!
#include <stdio.h>

long long ackermann(long long m, long long n) {
    if (m == 0) {
        return n + 1;
    } else if (n == 0) {
        return ackermann(m - 1, 1);
    } else {
        return ackermann(m - 1, ackermann(m, n - 1));
    }
}

int main() {
    printf("A(1, 2) = %lld\n", ackermann(1, 2));
    return 0;
}
\end{lstlisting}

\subsection{C++ Implementation}
A C++ implementation can look very similar to the C version, but might leverage C++ features for larger number handling (though the recursion limit remains the primary challenge).

\begin{lstlisting}[style=CppStyle, caption={C++ Implementation of the Ackermann Function}, label={lst:cpp_code}]
// C++ Code goes here.
#include <iostream>

long long ackermann(long long m, long long n) {
    if (m == 0) {
        return n + 1;
    } else if (n == 0) {
        return ackermann(m - 1, 1);
    } else {
        return ackermann(m - 1, ackermann(m, n - 1));
    }
}

int main() {
    std::cout << "A(1, 2) = " << ackermann(1, 2) << std::endl;
    return 0;
}
\end{lstlisting}

\subsection{Java Implementation}
In Java, the code structure is cleaner, housed within a class. We'll use the `long` type for the return value, equivalent to C's `long long`.

\begin{lstlisting}[style=JavaStyle, caption={Java Implementation of the Ackermann Function}, label={lst:java_code}]
// Java Code goes here.
public class Ackermann {
    public static long ackermann(long m, long n) {
        if (m == 0) {
            return n + 1;
        } else if (n == 0) {
            return ackermann(m - 1, 1);
        } else {
            return ackermann(m - 1, ackermann(m, n - 1));
        }
    }

    public static void main(String[] args) {
        System.out.println("A(1, 2) = " + ackermann(1, 2));
    }
}
\end{lstlisting}

\end{document}